# =========================================================
# Proyecto: Segmentación de Usuarios con Aprendizaje No Supervisado
# Modelos: K-means, DBSCAN, PCA y t-SNE
# Autor: Proyecto académico
# =========================================================

# =========================
# 1. Importación de librerías
# =========================

import numpy as np
import pandas as pd

import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import StandardScaler
from sklearn.cluster import KMeans, DBSCAN
from sklearn.metrics import silhouette_score
from sklearn.decomposition import PCA
from sklearn.manifold import TSNE

# Configuración visual
sns.set(style="whitegrid")
plt.rcParams["figure.figsize"] = (8, 6)

# =========================
# 2. Carga del dataset
# =========================

# Ajustar la ruta según el repositorio
data_path = "../data/dataset.csv"
df = pd.read_csv(data_path)

# Visualizar primeras filas
print(df.head())
print("\nDimensiones del dataset:", df.shape)

# =========================
# 3. Análisis Exploratorio de Datos (EDA)
# =========================

# Información general
print(df.info())

# Estadísticas descriptivas
print(df.describe())

# -------------------------
# Distribución de variables
# -------------------------

df.hist(bins=30, figsize=(14, 10))
plt.suptitle("Distribución de variables", fontsize=14)
plt.savefig(f"../figures/{plt.gca().get_title().replace(' ', '_')}.png", bbox_inches='tight')
plt.show()

# -------------------------
# Correlación
# -------------------------

plt.figure(figsize=(10, 8))
sns.heatmap(df.corr(), cmap="coolwarm", annot=False)
plt.title("Matriz de correlación")
plt.savefig(f"../figures/{plt.gca().get_title().replace(' ', '_')}.png", bbox_inches='tight')
plt.show()

# =========================
# 4. Preprocesamiento
# =========================

# Eliminación de columnas irrelevantes (si aplica)
# df = df.drop(columns=["columna_irrelevante"])

# Escalado de variables
scaler = StandardScaler()
X_scaled = scaler.fit_transform(df)

# =========================
# 5. K-means
# =========================

# -------------------------
# 5.1 Método del Codo
# -------------------------

inertia = []
K_range = range(2, 11)

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42)
    kmeans.fit(X_scaled)
    inertia.append(kmeans.inertia_)

plt.plot(K_range, inertia, marker="o")
plt.xlabel("Número de clusters (k)")
plt.ylabel("Inercia")
plt.title("Método del Codo para K-means")
plt.savefig(f"../figures/{plt.gca().get_title().replace(' ', '_')}.png", bbox_inches='tight')
plt.show()

# -------------------------
# 5.2 Silhouette Score
# -------------------------

silhouette_scores = []

for k in K_range:
    kmeans = KMeans(n_clusters=k, random_state=42)
    labels = kmeans.fit_predict(X_scaled)
    score = silhouette_score(X_scaled, labels)
    silhouette_scores.append(score)

plt.plot(K_range, silhouette_scores, marker="o")
plt.xlabel("Número de clusters (k)")
plt.ylabel("Silhouette Score")
plt.title("Silhouette Score para K-means")
plt.savefig(f"../figures/{plt.gca().get_title().replace(' ', '_')}.png", bbox_inches='tight')
plt.show()

# -------------------------
# 5.3 Entrenamiento final
# -------------------------

k_optimo = 4  # Ajustar según análisis previo
kmeans = KMeans(n_clusters=k_optimo, random_state=42)
df["cluster_kmeans"] = kmeans.fit_predict(X_scaled)

# =========================
# 6. DBSCAN
# =========================

# Ajuste de hiperparámetros

dbscan = DBSCAN(eps=0.8, min_samples=5)
df["cluster_dbscan"] = dbscan.fit_predict(X_scaled)

# Número de clusters detectados (excluyendo ruido)
clusters_dbscan = len(set(df["cluster_dbscan"])) - (1 if -1 in df["cluster_dbscan"].values else 0)
print("Clusters detectados por DBSCAN:", clusters_dbscan)

# =========================
# 7. PCA (Visualización 2D)
# =========================

pca = PCA(n_components=2)
X_pca = pca.fit_transform(X_scaled)

print("Varianza explicada por PCA:", pca.explained_variance_ratio_)

pca_df = pd.DataFrame(X_pca, columns=["PC1", "PC2"])
pca_df["cluster_kmeans"] = df["cluster_kmeans"]
pca_df["cluster_dbscan"] = df["cluster_dbscan"]

# -------------------------
# PCA + K-means
# -------------------------

sns.scatterplot(data=pca_df, x="PC1", y="PC2", hue="cluster_kmeans", palette="tab10")
plt.title("PCA (2D) - K-means")
plt.savefig(f"../figures/{plt.gca().get_title().replace(' ', '_')}.png", bbox_inches='tight')
plt.show()

# -------------------------
# PCA + DBSCAN
# -------------------------

sns.scatterplot(data=pca_df, x="PC1", y="PC2", hue="cluster_dbscan", palette="tab10")
plt.title("PCA (2D) - DBSCAN")
plt.savefig(f"../figures/{plt.gca().get_title().replace(' ', '_')}.png", bbox_inches='tight')
plt.show()

# =========================
# 8. t-SNE
# =========================

# Reducción no lineal

tsne = TSNE(n_components=2, perplexity=30, random_state=42)
X_tsne = tsne.fit_transform(X_scaled)

tsne_df = pd.DataFrame(X_tsne, columns=["TSNE1", "TSNE2"])
tsne_df["cluster_kmeans"] = df["cluster_kmeans"]
tsne_df["cluster_dbscan"] = df["cluster_dbscan"]

# -------------------------
# t-SNE + K-means
# -------------------------

sns.scatterplot(data=tsne_df, x="TSNE1", y="TSNE2", hue="cluster_kmeans", palette="tab10")
plt.title("t-SNE (2D) - K-means")
plt.savefig(f"../figures/{plt.gca().get_title().replace(' ', '_')}.png", bbox_inches='tight')
plt.show()

# -------------------------
# t-SNE + DBSCAN
# -------------------------

sns.scatterplot(data=tsne_df, x="TSNE1", y="TSNE2", hue="cluster_dbscan", palette="tab10")
plt.title("t-SNE (2D) - DBSCAN")
plt.savefig(f"../figures/{plt.gca().get_title().replace(' ', '_')}.png", bbox_inches='tight')
plt.show()

# =========================
# 9. Análisis de perfiles por cluster
# =========================

# ----------
# K-means
# ----------
cluster_summary = df.groupby("cluster_kmeans").mean()

# Exportar tabla de perfiles por cluster K-means
output_kmeans = "../figures/perfiles_cluster_kmeans.csv"
cluster_summary.to_csv(output_kmeans)

print("Resumen estadístico por cluster (K-means):")
print(cluster_summary)
print(f"
Tabla K-means exportada en: {output_kmeans}")

# ----------
# DBSCAN (excluyendo ruido = -1)
# ----------

dbscan_filtered = df[df["cluster_dbscan"] != -1]

if not dbscan_filtered.empty:
    dbscan_summary = dbscan_filtered.groupby("cluster_dbscan").mean()
    output_dbscan = "../figures/perfiles_cluster_dbscan.csv"
    dbscan_summary.to_csv(output_dbscan)

    print("
Resumen estadístico por cluster (DBSCAN, sin ruido):")
    print(dbscan_summary)
    print(f"
Tabla DBSCAN exportada en: {output_dbscan}")
else:
    print("
DBSCAN no generó clusters válidos (todos los puntos fueron clasificados como ruido).")

# =========================
# 10. Descripción automática de perfiles de usuario
# =========================

# Función para describir perfiles a partir de desviaciones estándar

def describir_perfiles(cluster_summary, scaler, feature_names, modelo="K-means"):
    print(f"\nDESCRIPCIÓN AUTOMÁTICA DE PERFILES ({modelo})")
    print("=" * 60)
    
    # Media global y desviación
    global_mean = pd.DataFrame(scaler.mean_, index=feature_names, columns=["media_global"])
    global_std = pd.DataFrame(np.sqrt(scaler.var_), index=feature_names, columns=["std_global"])
    
    for cluster in cluster_summary.index:
        print(f"\nPerfil Cluster {cluster}:")
        print("-" * 40)
        
        perfil = cluster_summary.loc[cluster]
        z_scores = (perfil - global_mean["media_global"]) / global_std["std_global"]
        
        for feature, z in z_scores.items():
            if z > 0.75:
                print(f"• {feature}: valor ALTO respecto al promedio")
            elif z < -0.75:
                print(f"• {feature}: valor BAJO respecto al promedio")
        
        print("Interpretación general: Usuario con comportamiento diferenciado en las variables destacadas.")

# ----------
# Descripción de perfiles K-means
# ----------

feature_names = df.drop(columns=["cluster_kmeans", "cluster_dbscan"]).columns

describir_perfiles(cluster_summary, scaler, feature_names, modelo="K-means")

# ----------
# Descripción de perfiles DBSCAN (sin ruido)
# ----------

if 'dbscan_summary' in locals():
    describir_perfiles(dbscan_summary, scaler, feature_names, modelo="DBSCAN")

# =========================
# 11. Conclusiones (comentarios finales)
# =========================

# - K-means permite identificar perfiles claros y compactos.
# - DBSCAN detecta ruido y usuarios atípicos.
# - PCA facilita interpretación global.
# - t-SNE revela estructuras complejas no lineales.

# Fin del notebook
